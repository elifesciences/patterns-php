#!/usr/bin/env php
<?php

use GitWrapper\Event\GitOutputStreamListener;
use GitWrapper\GitWorkingCopy;
use GitWrapper\GitWrapper;
use Rs\Json\Pointer;
use Symfony\Component\Filesystem\Filesystem;
use Symfony\Component\Finder\Finder;
use Symfony\Component\Process\Process;
use Symfony\Component\Process\ProcessBuilder;
use Symfony\Component\Yaml\Yaml;

require_once __DIR__.'/../vendor/autoload.php';

$sourceDir = __DIR__.'/../pattern-library';
$outputDir = __DIR__.'/../resources';
$filesystem = new Filesystem();
$wrapper = new GitWrapper();
$wrapper->addOutputListener(new GitOutputStreamListener());

if (false === is_dir($sourceDir)) {
    $repo = $wrapper->cloneRepository('git@github.com:elifesciences/pattern-library.git', $sourceDir);
} else {
    $repo = new GitWorkingCopy($wrapper, $sourceDir);
    if ($repo->hasChanges()) {
        $repo->reset(['hard' => true]);
    }
    $repo->pull();
}

ProcessBuilder::create()
    ->setArguments(['npm', 'install'])
    ->setWorkingDirectory($sourceDir)
    ->setTimeout(180)
    ->getProcess()
    ->enableOutput()
    ->mustRun(function ($type, $buffer) {
        if (Process::ERR === $type) {
            echo 'ERR > '.$buffer;
        } else {
            echo 'OUT > '.$buffer;
        }
    })
;

ProcessBuilder::create()
    ->setArguments(['gulp', '--environment', 'production'])
    ->setWorkingDirectory($sourceDir)
    ->getProcess()
    ->enableOutput()
    ->mustRun(function ($type, $buffer) {
        if (Process::ERR === $type) {
            echo 'ERR > '.$buffer;
        } else {
            echo 'OUT > '.$buffer;
        }
    })
;

$filesystem->mirror($sourceDir.'/source/assets', $outputDir.'/assets', null,
    ['override' => true, 'delete' => true]);
$filesystem->remove($outputDir.'/assets/img/fixtures/');

$patternDir = $sourceDir.'/source/_patterns';

$finder = (new Finder())->files()->in($patternDir)->name('*.yaml');

$filesystem->remove($outputDir.'/definitions/');
$filesystem->remove($outputDir.'/templates/');

foreach ($finder as $file) {
    $yaml = Yaml::parse($file->getContents());
    $yaml = resolveJsonReferences($yaml, $file);
    $yaml = Yaml::dump($yaml, 100);
    $yaml = str_replace(' {  }', ' []', $yaml);

    $filesystem->dumpFile($outputDir.'/definitions/'.$file->getFilename(), $yaml);

    $template = new SplFileInfo(substr($file->getRealPath(), 0, -4).'mustache');
    $filesystem->copy($template->getRealPath(), $outputDir.'/templates/'.$template->getFilename(), true);
}

/**
 * Naive JSON reference resolver than can handle YAML.
 *
 * @internal
 */
function resolveJsonReferences(array $json, SplFileInfo $file) : array
{
    foreach ($json as $key => $value) {
        if (is_array($value)) {
            $json[$key] = resolveJsonReferences($value, $file);
        } elseif ('$ref' === $key) {
            $parts = explode('#', $value, 2);

            if (empty($parts[0])) {
                $referenced = $file;
            } else {
                $referenced = new SplFileInfo(dirname($file->getRealPath()).'/'.$parts[0]);
            }

            if (null === $json = json_decode(file_get_contents($referenced->getRealPath()), true)) {
                $json = Yaml::parse(file_get_contents($referenced->getRealPath()));
            }

            $pointer = new Pointer(json_encode($json));

            return resolveJsonReferences($pointer->get($parts[1]), $referenced);
        }
    }

    return $json;
}
